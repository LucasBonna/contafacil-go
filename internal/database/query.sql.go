// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccessLog = `-- name: CreateAccessLog :one
INSERT INTO access_logs (
  id, ip, method, endpoint, request_body, request_headers,
  request_query, request_params, response_body, response_headers,
  response_time, status_code, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8,
  $9, $10, $11, $12, $13, $14
)
RETURNING id, ip, method, endpoint, request_body, request_headers, request_query, request_params, response_body, response_headers, response_time, status_code, created_at, updated_at
`

type CreateAccessLogParams struct {
	ID              pgtype.UUID
	Ip              string
	Method          string
	Endpoint        pgtype.Text
	RequestBody     pgtype.Text
	RequestHeaders  pgtype.Text
	RequestQuery    pgtype.Text
	RequestParams   pgtype.Text
	ResponseBody    pgtype.Text
	ResponseHeaders pgtype.Text
	ResponseTime    pgtype.Text
	StatusCode      pgtype.Int4
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) CreateAccessLog(ctx context.Context, arg CreateAccessLogParams) (AccessLog, error) {
	row := q.db.QueryRow(ctx, createAccessLog,
		arg.ID,
		arg.Ip,
		arg.Method,
		arg.Endpoint,
		arg.RequestBody,
		arg.RequestHeaders,
		arg.RequestQuery,
		arg.RequestParams,
		arg.ResponseBody,
		arg.ResponseHeaders,
		arg.ResponseTime,
		arg.StatusCode,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AccessLog
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.Method,
		&i.Endpoint,
		&i.RequestBody,
		&i.RequestHeaders,
		&i.RequestQuery,
		&i.RequestParams,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ResponseTime,
		&i.StatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
  id, file_name, extension, content_type,
  file_path, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, file_name, extension, content_type, file_path, created_at, updated_at, deleted_at
`

type CreateFileParams struct {
	ID          pgtype.UUID
	FileName    string
	Extension   string
	ContentType string
	FilePath    string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.ID,
		arg.FileName,
		arg.Extension,
		arg.ContentType,
		arg.FilePath,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Extension,
		&i.ContentType,
		&i.FilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createGNREEmission = `-- name: CreateGNREEmission :one
WITH new_emission AS (
    INSERT INTO emissions (
                           id,
                           emission_type,
                           client_id,
                           message,
                           status,
                           user_id
        ) VALUES (
                     gen_random_uuid(),
                     $6::text,
                     $7::uuid,
                     COALESCE($8::text, ''),
                     COALESCE($9::text, 'PENDING'),
                     $10::uuid
                 ) RETURNING id, created_at
)
INSERT INTO gnre_emissions (
    id,
    xml,
    guia_amount,
    chave_nota,
    num_nota,
    destinatario
) SELECT
      ne.id,
      $1::uuid,
      $2::double precision,
      $3::varchar,
      $4::varchar,
      $5::varchar
FROM new_emission ne
RETURNING
    id,
    (SELECT emission_type FROM emissions WHERE id = gnre_emissions.id) AS emission_type,
    (SELECT client_id FROM emissions WHERE id = gnre_emissions.id) AS client_id,
    (SELECT COALESCE(message, '') FROM emissions WHERE id = gnre_emissions.id) AS message,
    (SELECT COALESCE(status, 'PENDING') FROM emissions WHERE id = gnre_emissions.id) AS status,
    (SELECT user_id FROM emissions WHERE id = gnre_emissions.id) AS user_id,
    (SELECT created_at FROM emissions WHERE id = gnre_emissions.id) AS created_at,
    xml AS xml_file_id,
    guia_amount,
    chave_nota,
    num_nota,
    destinatario
`

type CreateGNREEmissionParams struct {
	XmlFileID    pgtype.UUID
	GuiaAmount   float64
	ChaveNota    string
	NumNota      string
	Destinatario string
	EmissionType pgtype.Text
	ClientID     pgtype.UUID
	Message      pgtype.Text
	Status       pgtype.Text
	UserID       pgtype.UUID
}

type CreateGNREEmissionRow struct {
	ID           pgtype.UUID
	EmissionType string
	ClientID     pgtype.UUID
	Message      pgtype.Text
	Status       string
	UserID       pgtype.UUID
	CreatedAt    pgtype.Timestamp
	XmlFileID    pgtype.UUID
	GuiaAmount   float64
	ChaveNota    string
	NumNota      string
	Destinatario string
}

func (q *Queries) CreateGNREEmission(ctx context.Context, arg CreateGNREEmissionParams) (CreateGNREEmissionRow, error) {
	row := q.db.QueryRow(ctx, createGNREEmission,
		arg.XmlFileID,
		arg.GuiaAmount,
		arg.ChaveNota,
		arg.NumNota,
		arg.Destinatario,
		arg.EmissionType,
		arg.ClientID,
		arg.Message,
		arg.Status,
		arg.UserID,
	)
	var i CreateGNREEmissionRow
	err := row.Scan(
		&i.ID,
		&i.EmissionType,
		&i.ClientID,
		&i.Message,
		&i.Status,
		&i.UserID,
		&i.CreatedAt,
		&i.XmlFileID,
		&i.GuiaAmount,
		&i.ChaveNota,
		&i.NumNota,
		&i.Destinatario,
	)
	return i, err
}

const getAllUsersByClientId = `-- name: GetAllUsersByClientId :many
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllUsersByClientIdParams struct {
	ClientID pgtype.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) GetAllUsersByClientId(ctx context.Context, arg GetAllUsersByClientIdParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsersByClientId, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.ApiKey,
			&i.Role,
			&i.ClientID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientByUserId = `-- name: GetClientByUserId :one
SELECT c.id, c.name, c.cnpj, c.role, c.created_at, c.updated_at, c.deleted_at FROM clients c
JOIN users u ON u.client_id = c.id
WHERE u.id = $1
LIMIT 1
`

func (q *Queries) GetClientByUserId(ctx context.Context, id pgtype.UUID) (Client, error) {
	row := q.db.QueryRow(ctx, getClientByUserId, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cnpj,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEmissionsByFilters = `-- name: GetEmissionsByFilters :many
SELECT e.id, e.emission_type, e.client_id, e.message, e.status, e.user_id,
       e.created_at, e.updated_at, e.deleted_at
FROM emissions e
WHERE 
    ($1::uuid IS NULL OR e.client_id = $1::uuid)
    AND ($2::text IS NULL OR e.status = $2::text)
    AND ($3::timestamp IS NULL OR e.created_at >= $3::timestamp)
    AND ($4::timestamp IS NULL OR e.created_at <= $4::timestamp)
    AND ($5::boolean = TRUE OR e.deleted_at IS NULL)
ORDER BY e.created_at DESC
LIMIT $7::integer OFFSET $6::integer
`

type GetEmissionsByFiltersParams struct {
	ClientID       pgtype.UUID
	Status         pgtype.Text
	StartDate      pgtype.Timestamp
	EndDate        pgtype.Timestamp
	IncludeDeleted bool
	RowOffset      int32
	RowLimit       int32
}

func (q *Queries) GetEmissionsByFilters(ctx context.Context, arg GetEmissionsByFiltersParams) ([]Emission, error) {
	rows, err := q.db.Query(ctx, getEmissionsByFilters,
		arg.ClientID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.IncludeDeleted,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Emission
	for rows.Next() {
		var i Emission
		if err := rows.Scan(
			&i.ID,
			&i.EmissionType,
			&i.ClientID,
			&i.Message,
			&i.Status,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one
SELECT id, file_name, extension, content_type, file_path, created_at, updated_at, deleted_at FROM files
where id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Extension,
		&i.ContentType,
		&i.FilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGNREEmissionByChaveNotaAndStatus = `-- name: GetGNREEmissionByChaveNotaAndStatus :one
SELECT g.id, g.xml, g.pdf, g.comprovante_pdf, g.guia_amount, g.numero_recibo, g.chave_nota, g.cod_barras_guia, g.num_nota, g.destinatario
FROM gnre_emissions g
JOIN emissions e ON g.id = e.id
WHERE g.chave_nota = $1 AND e.status = $2
LIMIT 1
`

type GetGNREEmissionByChaveNotaAndStatusParams struct {
	ChaveNota string
	Status    pgtype.Text
}

func (q *Queries) GetGNREEmissionByChaveNotaAndStatus(ctx context.Context, arg GetGNREEmissionByChaveNotaAndStatusParams) (GnreEmission, error) {
	row := q.db.QueryRow(ctx, getGNREEmissionByChaveNotaAndStatus, arg.ChaveNota, arg.Status)
	var i GnreEmission
	err := row.Scan(
		&i.ID,
		&i.Xml,
		&i.Pdf,
		&i.ComprovantePdf,
		&i.GuiaAmount,
		&i.NumeroRecibo,
		&i.ChaveNota,
		&i.CodBarrasGuia,
		&i.NumNota,
		&i.Destinatario,
	)
	return i, err
}

const getGNREEmissionById = `-- name: GetGNREEmissionById :one
SELECT g.id, g.xml, g.pdf, g.comprovante_pdf, g.guia_amount, g.numero_recibo, g.chave_nota, g.cod_barras_guia, g.num_nota, g.destinatario
FROM gnre_emissions g
JOIN emissions e ON g.id = e.id
WHERE g.id = $1
LIMIT 1
`

func (q *Queries) GetGNREEmissionById(ctx context.Context, id pgtype.UUID) (GnreEmission, error) {
	row := q.db.QueryRow(ctx, getGNREEmissionById, id)
	var i GnreEmission
	err := row.Scan(
		&i.ID,
		&i.Xml,
		&i.Pdf,
		&i.ComprovantePdf,
		&i.GuiaAmount,
		&i.NumeroRecibo,
		&i.ChaveNota,
		&i.CodBarrasGuia,
		&i.NumNota,
		&i.Destinatario,
	)
	return i, err
}

const getUserAndClientByApiKey = `-- name: GetUserAndClientByApiKey :one
SELECT
    users.id AS user_id,
    users.username,
    users.api_key,
    users.role AS user_role,
    users.client_id,
    users.created_at AS user_created_at,
    users.updated_at AS user_updated_at,
    users.deleted_at AS user_deleted_at,

    clients.id AS client_id,
    clients.name AS client_name,
    clients.cnpj AS client_cnpj,
    clients.role AS client_role,
    clients.created_at AS client_created_at,
    clients.updated_at AS client_updated_at,
    clients.deleted_at AS client_deleted_at
FROM
    users
JOIN
    clients ON users.client_id = clients.id
WHERE
    users.api_key = $1
LIMIT 1
`

type GetUserAndClientByApiKeyRow struct {
	UserID          pgtype.UUID
	Username        string
	ApiKey          string
	UserRole        pgtype.Text
	ClientID        pgtype.UUID
	UserCreatedAt   pgtype.Timestamp
	UserUpdatedAt   pgtype.Timestamp
	UserDeletedAt   pgtype.Timestamp
	ClientID_2      pgtype.UUID
	ClientName      string
	ClientCnpj      string
	ClientRole      pgtype.Text
	ClientCreatedAt pgtype.Timestamp
	ClientUpdatedAt pgtype.Timestamp
	ClientDeletedAt pgtype.Timestamp
}

func (q *Queries) GetUserAndClientByApiKey(ctx context.Context, apiKey string) (GetUserAndClientByApiKeyRow, error) {
	row := q.db.QueryRow(ctx, getUserAndClientByApiKey, apiKey)
	var i GetUserAndClientByApiKeyRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.ApiKey,
		&i.UserRole,
		&i.ClientID,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.UserDeletedAt,
		&i.ClientID_2,
		&i.ClientName,
		&i.ClientCnpj,
		&i.ClientRole,
		&i.ClientCreatedAt,
		&i.ClientUpdatedAt,
		&i.ClientDeletedAt,
	)
	return i, err
}

const getUserByApiKey = `-- name: GetUserByApiKey :one
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE api_key = $1
LIMIT 1
`

func (q *Queries) GetUserByApiKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByApiKey, apiKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.ApiKey,
		&i.Role,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE username = $1
LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.ApiKey,
		&i.Role,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAccessLog = `-- name: UpdateAccessLog :one
UPDATE access_logs
SET
  ip = $2,
  method = $3,
  endpoint = $4,
  request_body = $5,
  request_headers = $6,
  request_query = $7,
  request_params = $8,
  response_body = $9,
  response_headers = $10,
  response_time = $11,
  status_code = $12,
  updated_at = $13
WHERE id = $1
RETURNING id, ip, method, endpoint, request_body, request_headers, request_query, request_params, response_body, response_headers, response_time, status_code, created_at, updated_at
`

type UpdateAccessLogParams struct {
	ID              pgtype.UUID
	Ip              string
	Method          string
	Endpoint        pgtype.Text
	RequestBody     pgtype.Text
	RequestHeaders  pgtype.Text
	RequestQuery    pgtype.Text
	RequestParams   pgtype.Text
	ResponseBody    pgtype.Text
	ResponseHeaders pgtype.Text
	ResponseTime    pgtype.Text
	StatusCode      pgtype.Int4
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) UpdateAccessLog(ctx context.Context, arg UpdateAccessLogParams) (AccessLog, error) {
	row := q.db.QueryRow(ctx, updateAccessLog,
		arg.ID,
		arg.Ip,
		arg.Method,
		arg.Endpoint,
		arg.RequestBody,
		arg.RequestHeaders,
		arg.RequestQuery,
		arg.RequestParams,
		arg.ResponseBody,
		arg.ResponseHeaders,
		arg.ResponseTime,
		arg.StatusCode,
		arg.UpdatedAt,
	)
	var i AccessLog
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.Method,
		&i.Endpoint,
		&i.RequestBody,
		&i.RequestHeaders,
		&i.RequestQuery,
		&i.RequestParams,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ResponseTime,
		&i.StatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmissionAndGNRE = `-- name: UpdateEmissionAndGNRE :one
WITH check_exists AS (
    SELECT e.id
    FROM emissions e
             JOIN gnre_emissions g ON e.id = g.id
    WHERE e.id = $1
    LIMIT 1
),
     update_emission AS (
         UPDATE emissions
             SET
                 emission_type = COALESCE($2, emission_type),
                 client_id = COALESCE($3, client_id),
                 message = COALESCE($4, message),
                 status = COALESCE($5, status),
                 user_id = COALESCE($6, user_id),
                 updated_at = CURRENT_TIMESTAMP
             WHERE id = (SELECT id FROM check_exists)
             RETURNING id, emission_type, client_id, message, status, user_id, created_at, updated_at, deleted_at
     ),
     update_gnre AS (
         UPDATE gnre_emissions
             SET
                 xml = COALESCE($7::uuid, xml),
                 pdf = COALESCE($8::uuid, pdf),
                 comprovante_pdf = COALESCE($9::uuid, comprovante_pdf),
                 guia_amount = COALESCE($10::numeric, guia_amount),
                 numero_recibo = COALESCE($11::varchar, numero_recibo),
                 chave_nota = COALESCE($12::varchar, chave_nota),
                 cod_barras_guia = COALESCE($13::varchar, cod_barras_guia),
                 num_nota = COALESCE($14::varchar, num_nota),
                 destinatario = COALESCE($15::varchar, destinatario)
             WHERE id = (SELECT id FROM check_exists)
             RETURNING id, xml, pdf, comprovante_pdf, guia_amount, numero_recibo, chave_nota, cod_barras_guia, num_nota, destinatario
     )
SELECT
    e.id AS emission_id,
    e.emission_type,
    e.client_id,
    e.message,
    e.status,
    e.user_id,
    e.created_at AS emission_created_at,
    e.updated_at AS emission_updated_at,
    e.deleted_at AS emission_deleted_at,
    g.xml AS gnre_xml,
    g.pdf AS gnre_pdf,
    g.comprovante_pdf AS gnre_comprovante_pdf,
    g.guia_amount AS gnre_guia_amount,
    g.numero_recibo AS gnre_numero_recibo,
    g.chave_nota AS gnre_chave_nota,
    g.cod_barras_guia AS gnre_cod_barras_guia,
    g.num_nota AS gnre_num_nota,
    g.destinatario AS gnre_destinatario
FROM update_emission e
         JOIN update_gnre g ON e.id = g.id
`

type UpdateEmissionAndGNREParams struct {
	ID             pgtype.UUID
	EmissionType   pgtype.Text
	ClientID       pgtype.UUID
	Message        pgtype.Text
	Status         pgtype.Text
	UserID         pgtype.UUID
	Xml            pgtype.UUID
	Pdf            pgtype.UUID
	ComprovantePdf pgtype.UUID
	GuiaAmount     pgtype.Numeric
	NumeroRecibo   pgtype.Text
	ChaveNota      pgtype.Text
	CodBarrasGuia  pgtype.Text
	NumNota        pgtype.Text
	Destinatario   pgtype.Text
}

type UpdateEmissionAndGNRERow struct {
	EmissionID         pgtype.UUID
	EmissionType       string
	ClientID           pgtype.UUID
	Message            pgtype.Text
	Status             pgtype.Text
	UserID             pgtype.UUID
	EmissionCreatedAt  pgtype.Timestamp
	EmissionUpdatedAt  pgtype.Timestamp
	EmissionDeletedAt  pgtype.Timestamp
	GnreXml            pgtype.UUID
	GnrePdf            pgtype.UUID
	GnreComprovantePdf pgtype.UUID
	GnreGuiaAmount     float64
	GnreNumeroRecibo   pgtype.Text
	GnreChaveNota      string
	GnreCodBarrasGuia  pgtype.Text
	GnreNumNota        string
	GnreDestinatario   string
}

func (q *Queries) UpdateEmissionAndGNRE(ctx context.Context, arg UpdateEmissionAndGNREParams) (UpdateEmissionAndGNRERow, error) {
	row := q.db.QueryRow(ctx, updateEmissionAndGNRE,
		arg.ID,
		arg.EmissionType,
		arg.ClientID,
		arg.Message,
		arg.Status,
		arg.UserID,
		arg.Xml,
		arg.Pdf,
		arg.ComprovantePdf,
		arg.GuiaAmount,
		arg.NumeroRecibo,
		arg.ChaveNota,
		arg.CodBarrasGuia,
		arg.NumNota,
		arg.Destinatario,
	)
	var i UpdateEmissionAndGNRERow
	err := row.Scan(
		&i.EmissionID,
		&i.EmissionType,
		&i.ClientID,
		&i.Message,
		&i.Status,
		&i.UserID,
		&i.EmissionCreatedAt,
		&i.EmissionUpdatedAt,
		&i.EmissionDeletedAt,
		&i.GnreXml,
		&i.GnrePdf,
		&i.GnreComprovantePdf,
		&i.GnreGuiaAmount,
		&i.GnreNumeroRecibo,
		&i.GnreChaveNota,
		&i.GnreCodBarrasGuia,
		&i.GnreNumNota,
		&i.GnreDestinatario,
	)
	return i, err
}
