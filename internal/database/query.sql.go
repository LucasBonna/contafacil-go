// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccessLog = `-- name: CreateAccessLog :one
INSERT INTO access_logs (
  id, ip, method, endpoint, request_body, request_headers,
  request_query, request_params, response_body, response_headers,
  response_time, status_code, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8,
  $9, $10, $11, $12, $13, $14
)
RETURNING id, ip, method, endpoint, request_body, request_headers, request_query, request_params, response_body, response_headers, response_time, status_code, created_at, updated_at
`

type CreateAccessLogParams struct {
	ID              pgtype.UUID
	Ip              string
	Method          string
	Endpoint        pgtype.Text
	RequestBody     pgtype.Text
	RequestHeaders  pgtype.Text
	RequestQuery    pgtype.Text
	RequestParams   pgtype.Text
	ResponseBody    pgtype.Text
	ResponseHeaders pgtype.Text
	ResponseTime    pgtype.Text
	StatusCode      pgtype.Int4
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) CreateAccessLog(ctx context.Context, arg CreateAccessLogParams) (AccessLog, error) {
	row := q.db.QueryRow(ctx, createAccessLog,
		arg.ID,
		arg.Ip,
		arg.Method,
		arg.Endpoint,
		arg.RequestBody,
		arg.RequestHeaders,
		arg.RequestQuery,
		arg.RequestParams,
		arg.ResponseBody,
		arg.ResponseHeaders,
		arg.ResponseTime,
		arg.StatusCode,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AccessLog
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.Method,
		&i.Endpoint,
		&i.RequestBody,
		&i.RequestHeaders,
		&i.RequestQuery,
		&i.RequestParams,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ResponseTime,
		&i.StatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
  id, file_name, extension, content_type,
  file_path, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, file_name, extension, content_type, file_path, created_at, updated_at, deleted_at
`

type CreateFileParams struct {
	ID          pgtype.UUID
	FileName    string
	Extension   string
	ContentType string
	FilePath    string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.ID,
		arg.FileName,
		arg.Extension,
		arg.ContentType,
		arg.FilePath,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Extension,
		&i.ContentType,
		&i.FilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllUsersByClientId = `-- name: GetAllUsersByClientId :many
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllUsersByClientIdParams struct {
	ClientID pgtype.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) GetAllUsersByClientId(ctx context.Context, arg GetAllUsersByClientIdParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsersByClientId, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.ApiKey,
			&i.Role,
			&i.ClientID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientByUserId = `-- name: GetClientByUserId :one
SELECT c.id, c.name, c.cnpj, c.role, c.created_at, c.updated_at, c.deleted_at FROM clients c
JOIN users u ON u.client_id = c.id
WHERE u.id = $1
LIMIT 1
`

func (q *Queries) GetClientByUserId(ctx context.Context, id pgtype.UUID) (Client, error) {
	row := q.db.QueryRow(ctx, getClientByUserId, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Cnpj,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEmissionsByFilters = `-- name: GetEmissionsByFilters :many
SELECT e.id, e.emission_type, e.client_id, e.message, e.status, e.user_id,
       e.created_at, e.updated_at, e.deleted_at
FROM emissions e
WHERE 
    ($1::uuid IS NULL OR e.client_id = $1::uuid)
    AND ($2::text IS NULL OR e.status = $2::text)
    AND ($3::timestamp IS NULL OR e.created_at >= $3::timestamp)
    AND ($4::timestamp IS NULL OR e.created_at <= $4::timestamp)
    AND ($5::boolean = TRUE OR e.deleted_at IS NULL)
ORDER BY e.created_at DESC
LIMIT $7::integer OFFSET $6::integer
`

type GetEmissionsByFiltersParams struct {
	ClientID       pgtype.UUID
	Status         pgtype.Text
	StartDate      pgtype.Timestamp
	EndDate        pgtype.Timestamp
	IncludeDeleted bool
	RowOffset      int32
	RowLimit       int32
}

func (q *Queries) GetEmissionsByFilters(ctx context.Context, arg GetEmissionsByFiltersParams) ([]Emission, error) {
	rows, err := q.db.Query(ctx, getEmissionsByFilters,
		arg.ClientID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.IncludeDeleted,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Emission
	for rows.Next() {
		var i Emission
		if err := rows.Scan(
			&i.ID,
			&i.EmissionType,
			&i.ClientID,
			&i.Message,
			&i.Status,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one
SELECT id, file_name, extension, content_type, file_path, created_at, updated_at, deleted_at FROM files
where id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.Extension,
		&i.ContentType,
		&i.FilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGNREEmissionByChaveNotaAndStatus = `-- name: GetGNREEmissionByChaveNotaAndStatus :one
SELECT g.id, g.xml, g.pdf, g.comprovante_pdf, g.guia_amount, g.numero_recibo, g.chave_nota, g.cod_barras_guia, g.num_nota, g.destinatario
FROM gnre_emissions g
JOIN emissions e ON g.id = e.id
WHERE g.chave_nota = $1 AND e.status = $2
LIMIT 1
`

type GetGNREEmissionByChaveNotaAndStatusParams struct {
	ChaveNota string
	Status    pgtype.Text
}

func (q *Queries) GetGNREEmissionByChaveNotaAndStatus(ctx context.Context, arg GetGNREEmissionByChaveNotaAndStatusParams) (GnreEmission, error) {
	row := q.db.QueryRow(ctx, getGNREEmissionByChaveNotaAndStatus, arg.ChaveNota, arg.Status)
	var i GnreEmission
	err := row.Scan(
		&i.ID,
		&i.Xml,
		&i.Pdf,
		&i.ComprovantePdf,
		&i.GuiaAmount,
		&i.NumeroRecibo,
		&i.ChaveNota,
		&i.CodBarrasGuia,
		&i.NumNota,
		&i.Destinatario,
	)
	return i, err
}

const getUserAndClientByApiKey = `-- name: GetUserAndClientByApiKey :one
SELECT
    users.id AS user_id,
    users.username,
    users.api_key,
    users.role AS user_role,
    users.client_id,
    users.created_at AS user_created_at,
    users.updated_at AS user_updated_at,
    users.deleted_at AS user_deleted_at,

    clients.id AS client_id,
    clients.name AS client_name,
    clients.cnpj AS client_cnpj,
    clients.role AS client_role,
    clients.created_at AS client_created_at,
    clients.updated_at AS client_updated_at,
    clients.deleted_at AS client_deleted_at
FROM
    users
JOIN
    clients ON users.client_id = clients.id
WHERE
    users.api_key = $1
LIMIT 1
`

type GetUserAndClientByApiKeyRow struct {
	UserID          pgtype.UUID
	Username        string
	ApiKey          string
	UserRole        pgtype.Text
	ClientID        pgtype.UUID
	UserCreatedAt   pgtype.Timestamp
	UserUpdatedAt   pgtype.Timestamp
	UserDeletedAt   pgtype.Timestamp
	ClientID_2      pgtype.UUID
	ClientName      string
	ClientCnpj      string
	ClientRole      pgtype.Text
	ClientCreatedAt pgtype.Timestamp
	ClientUpdatedAt pgtype.Timestamp
	ClientDeletedAt pgtype.Timestamp
}

func (q *Queries) GetUserAndClientByApiKey(ctx context.Context, apiKey string) (GetUserAndClientByApiKeyRow, error) {
	row := q.db.QueryRow(ctx, getUserAndClientByApiKey, apiKey)
	var i GetUserAndClientByApiKeyRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.ApiKey,
		&i.UserRole,
		&i.ClientID,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.UserDeletedAt,
		&i.ClientID_2,
		&i.ClientName,
		&i.ClientCnpj,
		&i.ClientRole,
		&i.ClientCreatedAt,
		&i.ClientUpdatedAt,
		&i.ClientDeletedAt,
	)
	return i, err
}

const getUserByApiKey = `-- name: GetUserByApiKey :one
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE api_key = $1
LIMIT 1
`

func (q *Queries) GetUserByApiKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByApiKey, apiKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.ApiKey,
		&i.Role,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, api_key, role, client_id, created_at, updated_at, deleted_at FROM users
WHERE username = $1
LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.ApiKey,
		&i.Role,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAccessLog = `-- name: UpdateAccessLog :one
UPDATE access_logs
SET
  ip = $2,
  method = $3,
  endpoint = $4,
  request_body = $5,
  request_headers = $6,
  request_query = $7,
  request_params = $8,
  response_body = $9,
  response_headers = $10,
  response_time = $11,
  status_code = $12,
  updated_at = $13
WHERE id = $1
RETURNING id, ip, method, endpoint, request_body, request_headers, request_query, request_params, response_body, response_headers, response_time, status_code, created_at, updated_at
`

type UpdateAccessLogParams struct {
	ID              pgtype.UUID
	Ip              string
	Method          string
	Endpoint        pgtype.Text
	RequestBody     pgtype.Text
	RequestHeaders  pgtype.Text
	RequestQuery    pgtype.Text
	RequestParams   pgtype.Text
	ResponseBody    pgtype.Text
	ResponseHeaders pgtype.Text
	ResponseTime    pgtype.Text
	StatusCode      pgtype.Int4
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) UpdateAccessLog(ctx context.Context, arg UpdateAccessLogParams) (AccessLog, error) {
	row := q.db.QueryRow(ctx, updateAccessLog,
		arg.ID,
		arg.Ip,
		arg.Method,
		arg.Endpoint,
		arg.RequestBody,
		arg.RequestHeaders,
		arg.RequestQuery,
		arg.RequestParams,
		arg.ResponseBody,
		arg.ResponseHeaders,
		arg.ResponseTime,
		arg.StatusCode,
		arg.UpdatedAt,
	)
	var i AccessLog
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.Method,
		&i.Endpoint,
		&i.RequestBody,
		&i.RequestHeaders,
		&i.RequestQuery,
		&i.RequestParams,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ResponseTime,
		&i.StatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
